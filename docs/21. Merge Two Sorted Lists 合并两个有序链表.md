<!-- omit in toc -->
# 21. Merge Two Sorted Lists 合并两个有序链表

- Difficulty: Easy
- Topics: `Linked List`
- Link: https://leetcode-cn.com/problems/merge-two-sorted-lists/

- [Description](#description)
- [Solution](#solution)
  - [Two Pointers with new List](#two-pointers-with-new-list)
    - [Java](#java)
  - [Recursion](#recursion)
    - [Java](#java-1)
    - [Go](#go)
  - [Iteration](#iteration)
    - [Java](#java-2)
    - [Go](#go-1)
    - [Python3](#python3)
## Description

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：
```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

## Solution

### Two Pointers with new List

用双指针判断两个升序链表值的大小，生成一个新链表。

> 此法不是很合题意。题目希望我们能够就地修改，但是也能 work。

#### Java

- 208/208 cases passed (1 ms)
- Your runtime beats 62.97 % of java submissions
- Your memory usage beats 28.89 % of java submissions (38.6 MB))

```java
class Solution {

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode p1 = l1, p2 = l2;
        ListNode head = null, p3 = head;

        while (p1 != null && p2 != null) {
            if (p1.val <= p2.val) {
                if (p3 == null) {
                    // head
                    head = new ListNode(p1.val, null);
                    p3 = head;
                } else {
                    ListNode newNode = new ListNode(p1.val, null);
                    p3.next = newNode;
                    p3 = newNode;
                }
                p1 = p1.next;
            } else {
                if (p3 == null) {
                    // head
                    head = new ListNode(p2.val, null);
                    p3 = head;
                } else {
                    ListNode newNode = new ListNode(p2.val, null);
                    p3.next = newNode;
                    p3 = newNode;
                }
                p2 = p2.next;
            }
        }

        while (p1 != null) {
            if (p3 == null) {
                // head
                head = new ListNode(p1.val, null);
                p3 = head;
            } else {
                ListNode newNode = new ListNode(p1.val, null);
                p3.next = newNode;
                p3 = newNode;
            }
            p1 = p1.next;
        }

        while (p2 != null) {
            if (p3 == null) {
                // head
                head = new ListNode(p2.val, null);
                p3 = head;
            } else {
                ListNode newNode = new ListNode(p2.val, null);
                p3.next = newNode;
                p3 = newNode;
            }
            p2 = p2.next;
        }

        return head;
    }
}
```

### Recursion

递归的思想，说实话我的思路绝对不会像题解这么清晰。递归式如下：

![recursive-formula](assets/21.%20Merge%20Two%20Sorted%20Lists%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20200919125813232.png)

清晰易懂，只要根据 `list1[0] < list2[0]` 的比较结果拼接链表即可。由于递归是自上而下的调用方式，因此 `return` 值即为返回链表的 `HEAD`。

#### Java

- 208/208 cases passed (0 ms)
- Your runtime beats 100 % of java submissions
- Your memory usage beats 42.63 % of java submissions (38.5 MB)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        } else if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```

#### Go

- 208/208 cases passed (0 ms)
- Your runtime beats 100 % of golang submissions
- Your memory usage beats 29.09 % of golang submissions (2.5 MB)

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	} else if l2 == nil {
		return l1
	} else if l1.Val < l2.Val {
		l1.Next = mergeTwoLists(l1.Next, l2)
		return l1
	} else {
		l2.Next = mergeTwoLists(l1, l2.Next)
		return l2
	}
}
```

### Iteration

将 `prev` 作为遍历指针，将 `l1` 和 `l2` 作为缓存指针，并通过添加 dummy head 的方法，完美避开头节点特殊的判断条件。题解的这两个方法都很容易理解，而且给出的代码简洁优雅，必须要好好学习一个。

#### Java

- 208/208 cases passed (1 ms)
- Your runtime beats 62.88 % of java submissions
- Your memory usage beats 60.91 % of java submissions (38.5 MB)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode prehead = new ListNode();
        
        ListNode prev = prehead;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }

        prev.next = l1 == null ? l2 : l1;
        return prehead.next;
    }
}
```

#### Go

- 208/208 cases passed (4 ms)
- Your runtime beats 67.46 % of golang submissions
- Your memory usage beats 100 % of golang submissions (2.5 MB)

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	head := &ListNode{Val: -1, Next: nil}
	prev := head

	for l1 != nil && l2 != nil {
		if l1.Val <= l2.Val {
			prev.Next = l1
			l1 = l1.Next
		} else {
			prev.Next = l2
			l2 = l2.Next
		}
		prev = prev.Next
	}

	if l1 == nil {
		prev.Next = l2
	} else {
		prev.Next = l1
	}

	return head.Next
}
```

#### Python3

- 208/208 cases passed (28 ms)
- Your runtime beats 96.13 % of python3 submissions
- Your memory usage beats 22.41 % of python3 submissions (15.1 MB)

```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        
        p1, p2 = l1, l2
        # dummy head
        head = ListNode()
        cur = head

        while p1 and p2:
            if p1.val <= p2.val:
                # use l1 node
                cur.next = p1
                p1 = p1.next
            else:
                # use l2 node
                cur.next = p2
                p2 = p2.next

            cur = cur.next

        if p1:
            cur.next = p1
        elif p2:
            cur.next = p2
        
        return head.next
```
