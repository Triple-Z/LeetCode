# 46. Permutations 全排列

- Difficulty: Medium
- Topics: `Backtracking`
- Link: https://leetcode-cn.com/problems/permutations/

## Description

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

示例:
```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

## Solution

### Backtrack

最最经典的回溯题，一定要掌握！

回溯算法建立在递归结构的基础上，较为特别的一点是，回溯需要去修改递归结束后的操作值，以继续计算其他分支的可能结果。

该方法是将 `first` 作为分割线，`first` 索引以及左边的值为已经填入当前结果的内容，而 `first` 索引右侧的值为待填值。通过遍历并回溯待填值，我们就能够得出所有的可能排列结果。

- 25/25 cases passed (3 ms)
- Your runtime beats 40.51 % of java submissions
- Your memory usage beats 91.03 % of java submissions (38.6 MB)

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ans = new LinkedList<>();

        List<Integer> numList = IntStream.of(nums).boxed().collect(Collectors.toList());

        backtrack(ans, numList, nums.length, 0);
        return ans;
    }

    private void backtrack(List<List<Integer>> ans, List<Integer> numList, int n, int first) {
        if (first == n) {
            ans.add(new ArrayList<>(numList));
        }

        for (int i = first; i < n; i++) {
            Collections.swap(numList, first, i);
            backtrack(ans, numList, n, first + 1);
            // backtracking, swap back
            Collections.swap(numList, first, i);
        }
    }
}
```

### Yet Another Backtracking

2nd solution goes here.

```lang
2nd solution code goes here.
```