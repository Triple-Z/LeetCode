# 240. Search a 2D Matrix II 搜索二维矩阵 II

- Difficulty: Medium
- Topics: `Binary Search`, `Divide and Conquer`
- Link: https://leetcode-cn.com/problems/search-a-2d-matrix-ii/

## Description

编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。


示例 1：

![](https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg)
```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```
示例 2：

![](https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg)
```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

提示：
- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= n, m <= 300`
- `-109 <= matrix[i][j] <= 109`
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
- `-109 <= target <= 109`

## Solution

### Brute-force

暴力算法，逐一比对。时间复杂度为 `O(mn)`，空间复杂度为 `O(1)`。

- 128/128 cases passed (25 ms)
- Your runtime beats 5.5 % of java submissions
- Your memory usage beats 25.2 % of java submissions (44.4 MB)

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // brute-force
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (target == matrix[i][j]) return true;
            }
        }
        return false;
    }
}
```

### Binary Search

矩阵的元素遵循 从左到右、从上到下 的升序排列。对于有序数组中的查找，我们很自然的就想到了二分查找。但是，对于一个二维数组，应该如何做二分查找呢？

很显然，我们可以逐行或逐列搜索。事实上这个矩阵可能长宽并不相等，因此我们只需要搜索较小的值即可。[官方题解](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-2/) 还提供了一个新思路，即为：沿着对角线依次对该行、列上的元素进行二分搜索。

```lang
2nd solution code goes here.
```