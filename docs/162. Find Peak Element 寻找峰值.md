# 162. Find Peak Element 寻找峰值

- Difficulty: Medium
- Topics: `Array`, `Binary Search`
- Link: https://leetcode-cn.com/problems/find-peak-element/

## Description

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞`。

示例 1:
```
输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。
```
示例 2:
```
输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

说明:
- 你的解法应该是 O(logN) 时间复杂度的。

## Solution

### Binary Search

使用递归来实现二分查找。由于要判断两边元素，在处理边界条件之前，数组应该满足三个及以上元素个数的要求。在函数入口处添加数组长度判断即可，在实现二分查找的时候注意 corner cases 即可。

二分查找的时间复杂度为 `O(logn)`。

- 59/59 cases passed (0 ms)
- Your runtime beats 100 % of java submissions
- Your memory usage beats 68.17 % of java submissions (38.3 MB)

```java
class Solution {
    public int findPeakElement(int[] nums) {
        if (nums.length == 1) return 0;
        if (nums.length == 2) return nums[0] > nums[1] ? 0 : 1;
        return recursive(nums, 0, nums.length-1);
    }

    public int recursive(int[] nums, int left, int right) {
        if (left > right || left < 0 || right >= nums.length) return -1;
        int mid = left + (right - left) / 2;

        if (mid == 0) {
            if (nums[mid] > nums[mid+1]) return mid;
        } else if (mid == nums.length - 1 ) {
            if (nums[mid] > nums[mid-1]) return mid;
        } else {
            if (nums[mid] > nums[mid-1] && nums[mid] > nums[mid+1])  {
                return mid;
            }
        }

        return Math.max(recursive(nums, left, mid-1), recursive(nums, mid+1, right));
    }
}
```

### Binary Search (Recursive)

TODO：[官方题解](https://leetcode-cn.com/problems/find-peak-element/solution/xun-zhao-feng-zhi-by-leetcode/) 中的方法二，用了一点先验知识，让代码变得很简单。

2nd solution goes here.

```lang
2nd solution code goes here.
```

### Binary Search (Iteration) 

TODO：[官方题解](https://leetcode-cn.com/problems/find-peak-element/solution/xun-zhao-feng-zhi-by-leetcode/) 中的方法三，用迭代实现二分查找。
