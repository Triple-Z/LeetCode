# 53. Maximum Subarray

- Difficulty: Easy
- Topics: `Array`, `Divide and Conquer`, `Dynamic Programming`
- Link: https://leetcode.com/problems/maximum-subarray/

## Description

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

```
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

## Solution

### Brute Force (Time Limit Exceeded)

暴力算法，时间复杂度为 O(n^2)，会超时，无法 AC。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max_sum = nums[0];
        int sum = 0;
        
        for (auto it_i = nums.begin(); it_i != nums.end(); it_i++) {
            for (auto it_j = it_i; it_j != nums.end(); it_j++) {
                auto it = it_i;
                while (it != it_j + 1) {
                    sum += *it;
                    it++;
                }
                if (sum > max_sum) {
                    max_sum = sum;
                }
                sum = 0;
            }
        }
        
        return max_sum;
    }
};
```

### Divide and Conquer

### Dynamic Programming

动态规划的思想。由于题目的要求是找出最大的子序列之和，因此在遍历向量的过程中，我们可以直接修改向量，将当前元素的值设为其能达到的最大值。因此核心在于更新元素值为当前元素值与之前元素到当前元素和的最大值。再通过维护一个最大和数即可得到结果。该算法的时间复杂度为 O(n)，运行时间为 4ms，超过 100% 的 C++ 代码。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max_sum = nums[0];
        
        for (auto it = nums.begin(); it != nums.end(); it++) {
            // update nums[i]
            if (it != nums.begin()) {
                *it = max(*it, *(it-1) + *it);
            }
            // update max sum
            if (max_sum < *it) {
                max_sum = *it;
            }
        }
        
        return max_sum;
    }
};
```

### Kadane's Algorithm

[Kadane's algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm) 是最大子序列问题的最佳解法。算法时间复杂度为 O(n)，只需维护两个变量：`max_ending_here` 和 `max_so_far`。`max_ending_here` 的思路与动态规划一致，即为判断当前元素位置的最大和。`max_so_far` 则用于存储最大和值。该代码运行时间为 4ms，超过 100% 的 C++ 代码。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max_ending_here = 0, max_so_far = INT_MIN;
        
        for (int num: nums) {
            max_ending_here = max(num, max_ending_here + num);
            max_so_far = max(max_so_far, max_ending_here);
        }
        
        return max_so_far;
    }
};
```

